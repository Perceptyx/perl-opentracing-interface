=head1 NAME

OpenTracing::Interface::Scope - A role that defines the Scope interface

=head1 SYNOPSIS

    package OpenTracing::Implementation::MyBackendService::Scope;
        
    sub close {
        ...
    }
    
    sub get_span {
        ...
    }
    
    BEGIN {
        use Role::Tiny::With;
        with 'OpenTracing::Interface::Scope'
            if $ENV{OPENTRACING_INTERFACE};
    } # check at compile time, perl -c will work
    
    1;

=head1 DESCRIPTION

This 'role' describes the interface for any OpenTracing Scope
implementation.

A C<Scope> formalizes the activation and deactivation of a C<Span>, usually
from a CPU standpoint.

Many times a C<Span> will be extant (in that C<finish()> has not been called)
despite being in a non-runnable state from a CPU/scheduler standpoint. For
instance, a C<Span> representing the client side of an RPC will be unfinished
but blocked on IO while the RPC is still outstanding. A C<Scope> defines
when a given C<Span> B<is> scheduled and on the path.



=head1 INSTANCE METHODS



=head2 close

Mark the end of the active period for the current thread and L<Scope>,
updating the C<ScopeManager::active()> in the process.

    $scope->close;

NOTE: Calling C<close> more than once on a single C<Scope> instance leads
to undefined behavior.

=head3 Parameters

none

=head3 Returns

The C<Scope> instance <$self>, for ease of chaining (although the usefulness is
doubtfull).



=head2 get_span

Returns the C<Span> that's been scoped by this C<Scope>

    my $span = $scope->get_span

=head3 Parameters

none

=head3 Returns

The C<Span> that's been scoped by this C<Scope>.

=cut



=head1 SEE ALSO

=over

=item L<OpenTracing::Interface>

Describes the API definition for OpenTransport implementations written in the
Perl5 language.

=item L<OpenTracing::Types>

A library of L<Type::Tiny> type constraints that provides Duck Type checks for
all common elements that conform L<OpenTracing::Interface>

=back

=cut



=head1 CAVEATS

This description is using C<around> method modifiers that basically wraps them
around the real implementation. These method modifiers provide a 'readable' and
reusable interface, describing the inputs and outputs, using type constraints.

Consumers of this role, or implementors of the interface are MUST implement each
method mentioned below. Not doing so will result in compilation errors.

Since this role does nothing else than checking input and output, it is useful
during development. Most likely it can be switched off safely in production
environments.

=cut
